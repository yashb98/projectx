"use client"
// useref -> A react hook that creates a mutable refrence, aloowing us to persist state without causing re-renders
import { useRef } from "react"; 
// useDispatch -> A hoom from react-redux that aloows us to dispatch actions to the redux store
// useSelector -> a hook that lets components select parts of the Redux state
// TypedUseSelectorHook -> A typescript utility that ensures type safety for user selector
import {TypedUseSelectorHook, useDispatch, useSelector } from "react-redux";
// combineReducers -> A redux utility that merges multiple reducers into one
// configureStore -> A redux tookit funciton for setting up the store with default middlewares.
import {combineReducers, configureStore} from "@reduxjs/toolkit";
// Provider  -> A react component that provides the redux store to the react application
import { Provider } from "react-redux";
//  setupListeners -> A helper function that enables automatic refetching for RTK Query
import {setupListeners} from "@reduxjs/toolkit/query";
// globalReducer ->  A custom reducer imported from my project's state management files
import globalReducer from "@/state";
//  apiSlice -> A custom api slice imported from my project's state management files
import { api } from "@/state/api";

import {persistStore, persistReducer, FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER} from "redux-persist";
import { PersistGate } from "redux-persist/integration/react";
import createWebStorage from "redux-persist/lib/storage/createWebStorage";

// Redux Persistance
const createNoopStorage = () => {
    return {
        getItem(_key:any) {
            return Promise.resolve(null);
        }, setItem(_key:any, value:any) {
            return Promise.resolve(value);
        }, removeItem(_key:any) {
            return Promise.resolve();
        },
    };
};

const storage = 
    typeof window !== "undefined"
    ? createNoopStorage()
    : createWebStorage("local");

const persistConfig = {
    key:"root",
    storage,
    whitelist: ["global"],
}

// combineReducers merges multiple reducers into a single root reducers 
const rootReducer = combineReducers({
    global: globalReducer, // stores the application's global state
    [api.reducerPath]: api.reducer // integrates the API reducer (automatically) generated by createAPi in redux toolkit
});

const persistedReducer = persistReducer(persistConfig, rootReducer);


// Redux Store 

// A function that initialzes the Redux store
export const makeStore = () => {
    return configureStore({
        reducer: persistedReducer, 
        middleware: (getDefault) => 
            getDefault({
                serializableCheck: {
                    ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
                }
            }).concat(api.middleware) //appends api.muddleware for handling API requests     
        
    });
};

// Redux Types 
// AppStore -> Represents the RTedux store type
export type AppStore = ReturnType<typeof makeStore>;
// RootState -> Represents the global state structure 
export type RootState = ReturnType<AppStore['getState']>;
// Type for the dispatch function
export type AppDispatch = AppStore['dispatch'];

// A custom hook that ensures type safety when dispatching actions
export const useAppDispatch = () => useDispatch<AppDispatch>();
// A typed version of useSelector for selecting state slices
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;


// Provider 
// StoreProvider -> React component that wraps the application and provides access to the Redux Store 
export default function StoreProvider({
    children, // components inside StoreProvider will have access to the store
}: {
    children: React.ReactNode;
}) {
    // A refrence to store  the Redux instance
    const storeRef = useRef<AppStore|null>(null);
    // Ensures that the store is created only once
    // calls makeStore() to create a new store
    // calls setupListeners to enable RTK Query refetching
    if (!storeRef.current) {
        storeRef.current = makeStore();
        setupListeners(storeRef.current.dispatch);
    }
    const persistor = persistStore(storeRef.current);

    
    return(
        <Provider store={storeRef.current}>
            <PersistGate loading={null} persistor={persistor}>
            {children}
            </PersistGate>
            </Provider>

    ) 
}

















